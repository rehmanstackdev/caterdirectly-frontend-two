import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/auth';

export interface UnifiedOrder {
  id: string;
  order_number: string;
  host_id: string;
  vendor_id?: string;
  title: string;
  status: string;
  price: number;
  location?: string;
  date?: string;
  service_details?: any;
  booking_details?: any;
  pricing_snapshot?: any;
  client_name?: string;
  client_email?: string;
  client_phone?: string;
  client_company?: string;
  proposal_message?: string;
  proposal_expires_at?: string;
  vendor_message?: string;
  revision_message?: string;
  revision_number: number;
  created_at: string;
  updated_at?: string;
}

// Map orders_v2 row to UnifiedOrder interface
const mapToUnifiedOrder = (row: any): UnifiedOrder => ({
  id: row.id,
  order_number: row.order_number,
  host_id: row.host_id,
  vendor_id: row.vendor_id,
  title: row.title,
  status: row.order_status,
  price: (row.pricing_snapshot as any)?.total || 0,
  location: row.location,
  date: row.service_date || undefined,
  service_details: row.services,
  booking_details: row.booking_details,
  pricing_snapshot: row.pricing_snapshot,
  client_name: row.client_name,
  client_email: row.client_email,
  client_phone: row.client_phone,
  client_company: row.client_company,
  proposal_message: row.proposal_message,
  proposal_expires_at: row.proposal_expires_at,
  vendor_message: row.vendor_message,
  revision_message: row.revision_message,
  revision_number: row.revision_number || 0,
  created_at: row.created_at,
  updated_at: row.updated_at,
});

export function useUnifiedOrders() {
  const { toast } = useToast();
  const { user } = useAuth();
  const queryClient = useQueryClient();

  // Fetch all orders for the current user from orders_v2
  const { data: orders = [], isLoading, error } = useQuery({
    queryKey: ['unified-orders', user?.id],
    queryFn: async () => {
      if (!user?.id) return [];

      const { data, error } = await supabase
        .from('orders_v2')
        .select('*')
        .eq('host_id', user.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return (data || []).map(mapToUnifiedOrder);
    },
    enabled: !!user?.id,
  });

  // Create or update an order
  const saveOrderMutation = useMutation({
    mutationFn: async (orderData: Partial<UnifiedOrder>) => {
      if (!user?.id) throw new Error('User not authenticated');

      // Map UnifiedOrder back to orders_v2 format
      const v2Data: any = {
        ...orderData,
        order_status: orderData.status,
        service_date: orderData.date,
        services: orderData.service_details,
      };
      
      // Ensure pricing_snapshot is properly formatted
      if (orderData.price && !v2Data.pricing_snapshot) {
        v2Data.pricing_snapshot = {
          total: orderData.price,
          subtotal: orderData.price * 0.95,
          tax: orderData.price * 0.05,
        };
      }
      
      // Remove fields that don't exist in orders_v2 or are DB-generated
      delete v2Data.status;
      delete v2Data.date;
      delete v2Data.service_details;
      delete v2Data.price;
      delete v2Data.order_number; // Let DB generate
      delete v2Data.access_token; // Let DB generate

      // If order has an ID, update it; otherwise create new
      if (orderData.id) {
        const { data, error } = await supabase
          .from('orders_v2')
          .update({
            ...v2Data,
            updated_at: new Date().toISOString(),
          })
          .eq('id', orderData.id)
          .eq('host_id', user.id)
          .select()
          .single();

        if (error) throw error;
        return mapToUnifiedOrder(data);
      } else {
        const { data, error } = await supabase
          .from('orders_v2')
          .insert([{
            ...v2Data,
            host_id: user.id,
            title: orderData.title || 'Untitled Order',
            order_status: orderData.status || 'draft',
            revision_number: orderData.revision_number || 0,
            // order_number and access_token will be auto-generated by DB defaults
          }])
          .select()
          .single();

        if (error) throw error;
        return mapToUnifiedOrder(data);
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['unified-orders'] });
      toast({
        title: 'Success',
        description: 'Order saved successfully',
      });
    },
    onError: (error: Error) => {
      console.error('Error saving order:', error);
      toast({
        title: 'Error',
        description: 'Failed to save order',
        variant: 'destructive',
      });
    },
  });

  // Update order status
  const updateOrderStatusMutation = useMutation({
    mutationFn: async ({ orderId, status }: { orderId: string; status: string }) => {
      const { data, error } = await supabase
        .from('orders_v2')
        .update({ order_status: status })
        .eq('id', orderId)
        .select()
        .single();

      if (error) throw error;
      return mapToUnifiedOrder(data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['unified-orders'] });
    },
  });

  // Delete an order
  const deleteOrderMutation = useMutation({
    mutationFn: async (orderId: string) => {
      const { error } = await supabase
        .from('orders_v2')
        .delete()
        .eq('id', orderId)
        .eq('host_id', user?.id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['unified-orders'] });
      toast({
        title: 'Success',
        description: 'Order deleted successfully',
      });
    },
    onError: (error: Error) => {
      console.error('Error deleting order:', error);
      toast({
        title: 'Error',
        description: 'Failed to delete order',
        variant: 'destructive',
      });
    },
  });

  // Get a single order by ID
  const getOrder = async (orderId: string): Promise<UnifiedOrder | null> => {
    const { data, error } = await supabase
      .from('orders_v2')
      .select('*')
      .eq('id', orderId)
      .single();

    if (error) {
      console.error('Error fetching order:', error);
      return null;
    }

    return mapToUnifiedOrder(data);
  };

  // Get order by order number
  const getOrderByNumber = async (orderNumber: string): Promise<UnifiedOrder | null> => {
    const { data, error } = await supabase
      .from('orders_v2')
      .select('*')
      .eq('order_number', orderNumber)
      .single();

    if (error) {
      console.error('Error fetching order:', error);
      return null;
    }

    return mapToUnifiedOrder(data);
  };

  return {
    orders,
    isLoading,
    error,
    saveOrder: saveOrderMutation.mutate,
    updateOrderStatus: updateOrderStatusMutation.mutate,
    deleteOrder: deleteOrderMutation.mutate,
    getOrder,
    getOrderByNumber,
    isSaving: saveOrderMutation.isPending,
    isDeleting: deleteOrderMutation.isPending,
  };
}
